# 第五章、运输层

## 5.1  运输层协议概述

### 5.1.1  进程之间的通信

- 从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。
- 当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，只有位于网络边缘部分的主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三层的功能。 

**运输层的作用**

![运输层](img/第五章/运输层.png)

- “逻辑通信”的意思是“好像是这样通信，但事实上并非真的这样通信”。
- 从IP层来说，通信的两端是两台主机。但“两台主机之间的通信”这种说法还不够清楚。
- 严格地讲，两台主机进行通信就是两台主机中的应用进程互相通信。
- 从运输层的角度看，通信的真正端点并不是主机而是主机中的进程。也就是说，端到端的通信是应用进程之间的通信。

网络层和运输层有明显的区别：

<font color='red'>**网络层是为主机之间提供逻辑通信**</font>，
<font color='red'>**运输层为应用进程之间提供端到端的逻辑通信**</font>。

![应用进程间的通信](img/第五章/应用进程间的通信.png)



**运输层的作用**

- 在一台主机中经常有多个应用进程同时分别和另一台主机中的多个应用进程通信。
- 这表明运输层有一个很重要的功能——复用 (multiplexing)和分用 (demultiplexing)。
- 根据应用程序的不同需求，运输层需要有两种不同的运输协议，即面向连接的 TCP 和无连接的 UDP 。

**基于端口的** **复用** **和** **分用** **功能**

![复用与分用](img/第五章/复用与分用.png)



**两种不同的运输协议**

但这条逻辑通信信道对上层的表现却因运输层使用的不同协议而有很大的差别。

当运输层采用面向连接的 TCP 协议时，尽管下面的网络是不可靠的（只提供尽最大努力服务），但这种逻辑通信信道就相当于一条<font color='red'>**全双工的可靠信道**</font>。

当运输层采用无连接的 UDP 协议时，这种逻辑通信信道是一条不可靠信道。 

**可靠信道与不可靠信道**

![可靠信道与不可靠信道](img/第五章/可靠信道与不可靠信道.png)



### 5.1.2  运输层的两个主要协议

TCP/IP 的运输层有两个主要协议：

(1) 用户数据报协议 UDP (User Datagram Protocol)
(2) 传输控制协议 TCP (Transmission Control Protocol)

**UDP：一种无连接协议**

提供无连接服务。
传送的数据单位协议是 UDP 报文或用户数据报。
对方的运输层在收到 UDP 报文后，不需要给出任何确认。
虽然 UDP 不提供可靠交付，但在某些情况下 UDP 是一种最有效的工作方式。

**TCP：一种面向连接的协议**

提供面向连接的服务。
传送的数据单位协议是 TCP 报文段 (segment)。
<font color='red'>**TCP 不提供广播或多播服务**</font>。
由于 TCP 要提供可靠的、面向连接的运输服务，因此不可避免地增加了许多的开销。这不仅使协议数据单元的首部增大很多，还要占用许多的处理机资源。

**还要强调两点** 

运输层的 UDP 用户数据报与网际层的IP数据报有很大区别。

- IP 数据报要经过互连网中许多路由器的存储转发。
- UDP 用户数据报是在运输层的端到端抽象的逻辑信道中传送的。

TCP 报文段是在运输层抽象的端到端逻辑信道中传送，这种信道是可靠的全双工信道。但这样的信道却不知道究竟经过了哪些路由器，而这些路由器也根本不知道上面的运输层是否建立了 TCP 连接。 



### 5.1.3  运输层的端口

- 运行在计算机中的进程是用<font color='red'>**进程标识符PID**</font>来标志的。
- 但运行在应用层的各种应用进程却不应当让计算机操作系统指派它的进程标识符。这是因为在互联网上使用的计算机的操作系统种类很多，而不同的操作系统又使用不同格式的进程标识符。
- 为了使运行不同操作系统的计算机的应用进程能够互相通信，就必须<font color='red'>**用统一的方法对 TCP/IP 体系的应用进程进行标志**</font>。 

**端口号 (protocol port number)**

- 在运输层使用协议端口号，或通常简称为端口 (port)。
- 虽然通信的终点是应用进程，但我们可以把端口想象是通信的终点，因为我们只要把要传送的报文交到目的主机的某一个合适的目的端口，剩下的工作（即最后交付目的进程）就由 TCP 来完成。

**软件端口与硬件端口**

- <font color='red'>**在协议栈层间的抽象的协议端口是软件端口**</font>。
- <font color='red'>**路由器或交换机上的端口是硬件端口**</font>。
- 硬件端口是不同硬件设备进行交互的接口，而软件端口是应用层的各种协议进程与运输实体进行层间交互的一种地址。 

**TCP/IP** **运输层端口** 

- 端口用一个 16 比特表示。
- 端口号只具有本地意义，即端口号只是为了标志本计算机应用层中的各进程。
- 在互联网中，<font color='red'>**不同计算机的相同端口号是没有联系的**</font>。

由此可见，两个计算机中的进程要互相通信，不仅必须知道对方的 IP 地址（为了找到对方的计算机），而且还要知道对方的端口号（为了找到对方计算机中的应用进程）。

**两大类端口** 

(1) 服务器端使用的端口号

- <font color='cornflowerblue'>**熟知端口**</font>，数值一般为 0~1023。
- <font color='cornflowerblue'>**登记端口号**</font>，数值为 1024~49151，为没有熟知端口号的应用程序使用的。使用这个范围的端口号必须在 IANA 登记，以防止重复。

(2) 客户端使用的端口号

- <font color='cornflowerblue'>**短暂端口号**</font>，数值为 49152~65535，留给客户进程选择暂时使用。
- 当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用。 

**常用的熟知端口**

![熟知端口号](img/第五章/熟知端口号.png)



## 5.2  用户数据报协议 UDP

### 5.2.1  UDP 概述

UDP 只在 IP 的数据报服务之上增加了很少一点的功能：

- 复用和分用的功能
- 差错检测的功能

虽然 UDP 用户数据报只能提供不可靠的交付，但 UDP 在某些方面有其特殊的优点。

**UDP 的主要特点** 

(1)<font color='red'> **UDP 是无连接的**</font>，发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延。
(2) UDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的连接状态表。
(3) UDP 是面向报文的。<font color='red'>**UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界**</font>。UDP 一次交付一个完整的报文。
(4)<font color='red'> **UDP 没有拥塞控制**</font>，因此<font color='red'>**网络出现的拥塞不会使源主机的发送速率降低**</font>。这对某些实时应用是很重要的。很适合多媒体通信的要求。 
(5) UDP 支持一对一、一对多、多对一和多对多的交互通信。
(6) UDP 的首部开销小，只有 8 个字节，比 TCP 的 20 个字节的首部要短。

### 5.2.2  TCP和UDP对比 

![UDP和TCP对比1](img/第五章/UDP和TCP对比1.png)

![UDP和TCP对2比](img/第五章/UDP和TCP对2比.png)

![UDP和TCP对比 3](img/第五章/UDP和TCP对比 3.png)

![UDP和TCO对比4](img/第五章/UDP和TCO对比4.png)

## 5.3  传输控制协议 TCP 概述

### 5.3.1  TCP 最主要的特点

- TCP 是面向连接的运输层协议。
- 每一条 TCP 连接只能有两个端点，每一条 TCP 连接只能是点对点的（一对一）。 
- TCP 提供可靠交付的服务。
- TCP 提供全双工通信。
- 面向字节流
  - TCP 中的“流”(stream)指的是流入或流出进程的字节序列。
  - “面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块，但 TCP 把应用程序交下来的数据看成仅仅是一连串无结构的字节流。

**TCP 面向流的概念** 

- TCP 不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系。
- 但接收方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样。

![TCP面向流](img/第五章/TCP面向流.png)

TCP 不关心应用进程一次把多长的报文发送到 TCP 缓存。

TCP 对连续的字节流进行分段，形成 TCP 报文段。

**注意**

- <font color='red'>**TCP 连接是一条虚连接而不是一条真正的物理连接**</font>。
- TCP 对应用进程一次把多长的报文发送到TCP 的缓存中是不关心的。
- TCP 根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节（UDP 发送的报文长度是应用进程给出的）。
- TCP 可把太长的数据块划分短一些再传送。
- TCP 也可等待积累有足够多的字节后再构成报文段发送出去。 

### 5.3.2  TCP 的连接

- TCP 把连接作为最基本的抽象。
- 每一条 TCP 连接有两个端点。
- TCP 连接的端点不是主机，不是主机的IP 地址，不是应用进程，也不是运输层的协议端口。TCP 连接的端点叫做套接字 (socket) 或插口。
- 端口号拼接到 IP 地址即构成了套接字。   

**套接字 (socket)**

套接字 socket = (IP地址 : 端口号)          

每一条 TCP 连接唯一地被通信两端的两个端点（即两个套接字）所确定。



## 5.5  TCP 报文段的首部格式

TCP 虽然是面向字节流的，但 TCP 传送的数据单元却是报文段。

一个 TCP 报文段分为首部和数据两部分，而 TCP 的全部功能都体现在它首部中各字段的作用。

TCP 报文段首部的前 20 个字节是固定的，后面有 4n 字节是根据需要而增加的选项 (n 是整数)。因此 TCP 首部的最小长度是 20 字节。

**TCP 报文段的首部格式** 

![TCP报文](img/第五章/TCP报文.png)

- 源端口和目的端口字段——各占 2 字节。端口是运输层与应用层的服务接口。运输层的复用和分用功能都要通过端口才能实现。  
- 序号字段——占 4 字节。TCP 连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。 
- 确认号字段——占 4 字节，是期望收到对方的下一个报文段的数据的第一个字节的序号。 
- 数据偏移（即首部长度）——占 4 位，它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。“数据偏移”的单位是 32 位字（以 4 字节为计算单位）。  
- 保留字段——占 6 位，保留为今后使用，但目前应置为 0。 
- 紧急 URG —— 当 URG  1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)。 
- 确认 ACK —— 只有当 ACK  1 时确认号字段才有效。当 ACK  0 时，确认号无效。 
- 推送 PSH (PuSH) —— 接收 TCP 收到 PSH = 1 的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付。  
- 复位 RST (ReSeT) —— 当 RST  1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。 
- 同步 SYN —— 同步 SYN = 1 表示这是一个连接请求或连接接受报文。 
- 终止 FIN (FINish) —— 用来释放一个连接。FIN  1 表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。 
- 窗口字段 —— 占 2 字节，用来让对方设置发送窗口的依据，单位为字节。
- 检验和 —— 占 2 字节。检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。
- 紧急指针字段 —— 占 16 位，指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）。 
-  选项字段 —— 长度可变。TCP 最初只规定了一种选项，即最大报文段长度 MSS。MSS 告诉对方 TCP：“我的缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节。” 

![例题1](img/第五章/例题1.png)



## 5.6  TCP 可靠传输的实现

### 5.6.1  以字节为单位的滑动窗口

TCP 的滑动窗口是以字节为单位的。

现假定 A 收到了 B 发来的确认报文段，其中窗口是 20 字节，而确认号是 31（这表明 B 期望收到的下一个序号是 31，而序号 30 为止的数据已经收到了）。

根据这两个数据，A 就构造出自己的发送窗口，

根据 B 给出的窗口值，A 构造出自己的发送窗口。
发送窗口表示：在没有收到 B 的确认的情况下，A 可以连续把窗口内的数据都发送出去。 
发送窗口里面的序号表示允许发送的序号。
显然，窗口越大，发送方就可以在收到对方确认之前连续发送更多的数据，因而可能获得更高的传输效率。

![滑动窗口移动](img/第五章/滑动窗口移动.png)

如何描述发送窗口的状态？使用三个指针来标记

![滑动窗口三指针](img/第五章/滑动窗口三指针.png)

![滑动窗口未按序到达](img/第五章/滑动窗口未按序到达.png)



![滑动窗口停止发送](img/第五章/滑动窗口停止发送.png)



**发送缓存** 

发送方的应用进程把字节流写入 TCP 的发送缓存。

![发送缓存](img/第五章/发送缓存.png)

**接收缓存**

接收方的应用进程从 TCP 的接收缓存中读取字节流。

![接收缓存](img/第五章/接收缓存.png)

**发送缓存与接收缓存的作用**

发送缓存用来暂时存放：

- 发送应用程序传送给发送方 TCP 准备发送的数据；
- TCP 已发送出但尚未收到确认的数据。

接收缓存用来暂时存放：

- 按序到达的、但尚未被接收应用程序读取的数据；
- 不按序到达的数据。 

**需要强调三点**

- 第一，A 的发送窗口并不总是和 B 的接收窗口一样大（因为有一定的时间滞后）。
- 第二，TCP 标准没有规定对不按序到达的数据应如何处理。通常是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程。
- 第三，TCP 要求接收方必须有累积确认的功能，这样可以减小传输开销。  

**接收方发送确认**

接收方可以在合适的时候发送确认，也可以在自己有数据要发送时把确认信息顺便捎带上。

但请注意两点：

- 第一，接收方不应过分推迟发送确认，否则会导致发送方不必要的重传，这反而浪费了网络的资源。。 
- 第二，捎带确认实际上并不经常发生，因为大多数应用程序很少同时在两个方向上发送数据。

![例题3](img/第五章/例题3.png)

<font color='red'>**TCP只对已按序到达的最高序号进行确认**</font>

![例题4](img/第五章/例题4.png)

### 5.6.2  超时重传时间的选择

- 重传机制是 TCP 中最重要和最复杂的问题之一。
- TCP 每发送一个报文段，就对这个报文段设置一次计时器。
- 只要计时器设置的重传时间到但还没有收到确认，就要重传这一报文段。
- 重传时间的选择是 TCP 最复杂的问题之一。

**TCP 超时重传时间设置**

如果把超时重传时间设置得太短，就会引起很多报文段的不必要的重传，使网络负荷增大。
但若把超时重传时间设置得过长，则又使网络的空闲时间增大，降低了传输效率。

![超时重传时间的选择](img/第五章/超时重传时间的选择.png)

TCP 采用了一种自适应算法，它记录一个报文段发出的时间，以及收到相应的确认的时间。这两个时间之差就是报文段的往返时间 RTT。

**加权平均往返时间RTT和超时重传时间RTO**

![RTT和RTO](img/第五章/RTT和RTO.png)



**往返时间 (RTT) 的测量相当复杂** 

- TCP 报文段 1 没有收到确认。重传（即报文段 2）后，收到了确认报文段 ACK。
- 如何判定此确认报文段是对原来的报文段 1 的确认，还是对重传的报文段 2 的确认？ 

![RTT测量](img/第五章/RTT测量.png)



**Karn 算法** 

在计算平均往返时间 RTT 时，只要报文段重传了，就不采用其往返时间样本。

这样得出的加权平均平均往返时间 RTTS 和超时重传时间 RTO 就较准确。

但是，这又引起新的问题。当报文段的时延突然增大了很多时，在原来得出的重传时间内，不会收到确认报文段。于是就重传报文段。但根据 Karn 算法，不考虑重传的报文段的往返时间样本。这样，超时重传时间就无法更新。

**修正的 Karn 算法** 

报文段每重传一次，就把 RTO 增大一些：

新的RTO = γ * (旧的RTO)

系数γ的典型值是 2 。

当不再发生报文段的重传时，才根据报文段的往返时延更新平均往返时延 RTT 和超时重传时间 RTO 的数值。

实践证明，这种策略较为合理。 

![例题2](img/第五章/例题2.png)





## 5.7  TCP 的流量控制

### 5.7.1  利用滑动窗口实现流量控制

- 一般说来，我们总是希望数据传输得更快一些。但如果发送方把数据发送得过快，接收方就可能来不及接收，这就会造成数据的丢失。
- 流量控制就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。
- 利用滑动窗口机制可以很方便地在 TCP 连接上实现流量控制。 

**利用可变窗口进行流量控制举例**

A 向 B 发送数据。在连接建立时，B 告诉 A：
“我的接收窗口 rwnd = 400（字节）”。

![流量控制](img/第五章/流量控制.png)

**可能发生死锁**

B 向 A 发送了零窗口的报文段后不久，B 的接收缓存又有了一些存储空间。于是 B 向 A 发送了 rwnd = 300 的报文段。

但这个报文段在传送过程中丢失了。A 一直等待收到 B 发送的非零窗口的通知，而 B 也一直等待 A 发送的数据。

![死锁](img/第五章/死锁.png)

为了解决这个问题，TCP 为每一个连接设有一个持续计时器 (persistence timer)。

**持续计时器**

TCP 为每一个连接设有一个持续计时器  (persistence timer) 。

<font color='red'>只要 TCP 连接的一方收到对方的零窗口通知，就启动该持续计时器</font>。

若持续计时器设置的时间到期，就发送一个零窗口探测报文段（仅携带 1 字节的数据），而对方就在确认这个探测报文段时给出了现在的窗口值。

若窗口仍然是零，则收到这个报文段的一方就<font color='red'>重新设置持续计时器</font>。

若窗口不是零，则死锁的僵局就可以打破了。 

![20240613155345](F:/QQ Cache/3168568813/Image/SharePic/20240613155345.png)

![流量控制例题](img/第五章/流量控制例题.png)



## 5.8  TCP 的拥塞控制

### 5.8.1  拥塞控制的一般原理

在某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种现象称为拥塞 (congestion)。

若网络中有许多资源同时产生拥塞，网络的性能就要明显变坏，整个网络的吞吐量将随输入负荷的增大而下降。

出现拥塞的原因：<u>网络对资源的需求 > 可用资源</u>

**增加资源能解决拥塞吗？**

不能。这是因为网络拥塞是一个非常复杂的问题。简单地采用上述做法，在许多情况下，不但不能解决拥塞问题，而且还可能使网络的性能更坏。

网络拥塞往往是由许多因素引起的。例如：

- 增大缓存，但未提高输出链路的容量和处理机的速度，排队等待时间将会大大增加，引起大量超时重传，解决不了网络拥塞；
- 提高处理机处理的速率会会将瓶颈转移到其他地方；

**拥塞常常趋于恶化**

如果一个路由器没有足够的缓存空间，它就会丢弃一些新到的分组。
但当分组被丢弃时，发送这一分组的源点就会重传这一分组，甚至可能还要重传多次。这样会引起更多的分组流入网络和被网络中的路由器丢弃。
可见拥塞引起的重传并不会缓解网络的拥塞，反而会加剧网络的拥塞。

**拥塞控制与流量控制的区别** 

- <font color='red'>**拥塞控制就是防止过多的数据注入到网络中，使网络中的路由器或链路不致过载。**</font>
- 拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。
- 拥塞控制是一个全局性的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。 
- 流量控制往往指点对点通信量的控制，是个端到端的问题（接收端控制发送端）。
- <font color='red'>**流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。**</font> 

拥塞控制和流量控制之所以常常被弄混，是因为某些拥塞控制算法是向发送端发送控制报文，并告诉发送端，网络已出现麻烦，必须放慢发送速率。这点又和流量控制是很相似的。

**拥塞控制所起的作用** 

![拥塞控制曲线](img/第五章/拥塞控制曲线.png)

### 5.8.2  TCP 的拥塞控制方法

TCP 采用基于窗口的方法进行拥塞控制。该方法属于闭环控制方法。

TCP发送方维持一个拥塞窗口 CWND (Congestion Window)

- 拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。

- 发送端利用拥塞窗口根据网络的拥塞情况调整发送的数据量。

- 所以，发送窗口大小不仅取决于接收方公告的接收窗口，还取决于网络的拥塞状况，所以真正的发送窗口值为：

  真正的发送窗口值 = Min(公告窗口值，拥塞窗口值)

**控制拥塞窗口的原则**

只要网络没有出现拥塞，拥塞窗口就可以再增大一些，以便把更多的分组发送出去，这样就可以提高网络的利用率。
但只要网络出现拥塞或有可能出现拥塞，就必须把拥塞窗口减小一些，以减少注入到网络中的分组数，以便缓解网络出现的拥塞。

**拥塞的判断**

重传定时器超时

- 现在通信线路的传输质量一般都很好，因传输出差错而丢弃分组的概率是很小的（远小于 1 %）。只要出现了超时，就可以猜想网络可能出现了拥塞。

收到三个相同（重复）的 ACK

- 个别报文段会在网络中丢失，预示可能会出现拥塞（实际未发生拥塞），因此可以尽快采取控制措施，避免拥塞。

#### **TCP拥塞控制算法**

##### **慢开始 **

用来确定网络的负载能力。

算法的思路：由小到大逐渐增大拥塞窗口数值。

初始拥塞窗口 cwnd 设置：

- 旧的规定：在刚刚开始发送报文段时，先把初始拥塞窗口cwnd 设置为 1 至 2 个发送方的最大报文段 SMSS (Sender Maximum Segment Size) 的数值。
- 新的 RFC 5681 把初始拥塞窗口 cwnd 设置为不超过2至4个SMSS 的数值。

慢开始门限 ssthresh（状态变量）：防止拥塞窗口cwnd 增长过大引起网络拥塞。

拥塞窗口 cwnd  控制方法：在每收到一个对新的报文段的确认后，可以把拥塞窗口增加最多一个 SMSS 的数值。

​	拥塞窗口cwnd每次的增加量 = min (N, SMSS)     

其中 N 是原先未被确认的、但现在被刚收到的确认报文段所确认的字节数。

不难看出，当 N < SMSS 时，拥塞窗口每次的增加量要小于 SMSS。

用这样的方法逐步增大发送方的拥塞窗口 cwnd，可以使分组注入到网络的速率更加合理。

![慢开始](img/第五章/慢开始.png)

**传输轮次**

使用慢开始算法后，每经过一个传输轮次 (transmission round)，拥塞窗口 cwnd 就加倍。 

一个传输轮次所经历的时间其实就是往返时间 RTT。

“传输轮次”更加强调：把拥塞窗口 cwnd 所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。

例如，拥塞窗口 cwnd = 4，这时的往返时间 RTT 就是发送方连续发送 4 个报文段，并收到这 4 个报文段的确认，总共经历的时间。 

**设置慢开始门限状态变量 ssthresh**

慢开始门限 ssthresh 的用法如下：

- 当 cwnd < ssthresh 时，使用慢开始算法。
- 当 cwnd > ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。
- 当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞避免算法。

##### **拥塞避免**

思路：让拥塞窗口 cwnd 缓慢地增大，即每经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd 加 1，而不是加倍，使拥塞窗口 cwnd 按线性规律缓慢增长。

因此在拥塞避免阶段就有“加法增大”  (Additive Increase) 的特点。这表明在拥塞避免阶段，拥塞窗口 cwnd 按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。

**当网络出现拥塞时**

无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（重传定时器超时）：

- ssthresh = max(cwnd/2，2)
- cwnd = 1
- 执行慢开始算法

这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。 

**慢开始和拥塞避免算法的实现举例 **

![拥塞避免与慢开始](img/第五章/拥塞避免与慢开始.png)

当 TCP 连接进行初始化时，将拥塞窗口置为 1。图中的窗口单位不使用字节而使用报文段。

慢开始门限的初始值设置为 16 个报文段，即 ssthresh = 16。

发送端的发送窗口不能超过拥塞窗口 cwnd 和接收端窗口 rwnd 中的最小值。我们假定接收端窗口足够大，因此现在发送窗口的数值等于拥塞窗口的数值。

- 在执行慢开始算法时，拥塞窗口 cwnd=1，发送第一个报文段。
- 发送方每收到一个对新报文段的确认 ACK，就把拥塞窗口值加 1，然后开始下一轮的传输（请注意，横坐标是传输轮次，不是时间）。因此拥塞窗口 cwnd 随着传输轮次按指数规律增长。
- 当拥塞窗口 cwnd 增长到慢开始门限值s sthresh 时（图中的点1，此时拥塞窗口cwnd = 16），就改为执行拥塞避免算法，拥塞窗口按线性规律增长。
- 当拥塞窗口 cwnd = 24 时，网络出现了超时（图中的点2），发送方判断为网络拥塞。于是调整门限值 ssthresh = cwnd / 2 = 12，同时设置拥塞窗口 cwnd = 1，进入慢开始阶段。
- 按照慢开始算法，发送方每收到一个对新报文段的确认ACK，就把拥塞窗口值加1。当拥塞窗口cwnd = ssthresh = 12时（图中的点3，这是新的ssthresh值），改为执行拥塞避免算法，拥塞窗口按线性规律增大。
- 当拥塞窗口cwnd = 16时（图中的点4），出现了一个新的情况，就是<font color='red'>**发送方一连收到 3 个对同一个报文段的重复确认**</font>（图中记为3-ACK）。发送方改为执行快重传和快恢复算法。

**必须强调指出** 

“拥塞避免”并非指完全能够避免了拥塞。利用以上的措施要完全避免网络拥塞还是不可能的。
“拥塞避免”是说在拥塞避免阶段把拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。 

##### **快重传**

采用快重传FR (Fast Retransmission) 算法可以让发送方尽早知道发生了个别报文段的丢失。

快重传算法首先要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认，即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认。

发送方只要<font color='red'>**一连收到三个重复确认**</font>，就知道接收方确实没有收到报文段，因而应当立即进行重传（即“快重传”），这样就不会出现超时，发送方也不就会误认为出现了网络拥塞。

使用快重传可以使整个网络的吞吐量提高约20%。 

​		不难看出，快重传并非取消重传计时器，而是在某些情况下可更早地重传丢失的报文段。 

**快重传举例**

![快重传](img/第五章/快重传.png)

##### **快恢复**

当发送端收到连续三个重复的确认时，由于发送方现在认为网络很可能没有发生拥塞，因此现在不执行慢开始算法，而是执行快恢复算法 FR (Fast Recovery) 算法：
	(1) 慢开始门限 ssthresh = 当前拥塞窗口 cwnd / 2 ；
	(2) 新拥塞窗口 cwnd = 慢开始门限 ssthresh ；
	(3) 开始执行拥塞避免算法，使拥塞窗口缓慢地线性增大。 

**快恢复和拥塞避免的实现举例** 

![](images/QQ截图20200407173019.png)

**发送窗口的上限值**

发送方的发送窗口的上限值应当取为接收方窗口 rwnd 和拥塞窗口 cwnd 这两个变量中较小的一个，即应按以下公式确定：

发送窗口的上限值Min [rwnd, cwnd] 

当 rwnd < cwnd 时，是接收方的接收能力限制发送窗口的最大值。

当 cwnd < rwnd 时，则是网络的拥塞限制发送窗口的最大值。 

也就是说，rwnd 和 cwnd 中数值较小的一个，控制了发送方发送数据的速率。

## 5.9  TCP 的运输连接管理

**运输连接的三个阶段**

TCP 是面向连接的协议。
运输连接有三个阶段：

- 连接建立
- 数据传送
- 连接释放

运输连接的管理就是使运输连接的建立和释放都能正常地进行。

**TCP 连接建立过程中要解决的三个问题**

(1) 要使每一方能够确知对方的存在。
(2) 要允许双方协商一些参数（如最大窗口值、是否使用窗口扩大选项和时间戳选项以及服务质量等）。
(3) 能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配。

客户-服务器方式 

TCP连接的建立采用客户服务器方式。
主动发起连接建立的应用进程叫做客户(client)，
被动等待连接建立的应用进程叫做服务器(server)。

### 5.9.1  TCP 的连接建立

#### **三报文握手**

![三握手](img/第五章/三握手.png)

- A 的 TCP 向 B 发出连接请求报文段，其首部中的同步位 SYN = 1，并选择序号 seq = x，表明传送数据时的第一个数据字节的序号是 x。

- B 的 TCP 收到连接请求报文段后，如同意，则  发回确认。
  B 在确认报文段中应使 SYN = 1，使 ACK = 1，其确认号ack = x + 1，自己选择的序号 seq = y。

- A 收到此报文段后向 B 给出确认，其 ACK = 1，确认号 ack = y + 1。
  A 的 TCP 通知上层应用进程，连接已经建立。   
- B 的 TCP 收到主机 A 的确认后，也通知其上层应用进程：TCP 连接已经建立。

采用三报文握手建立 TCP 连接的各状态 

**如果取消第三次握手会怎么样？**

TCP第一次发送连接请求，但请求在网络中滞留，客户端未收到确认而超时重传，第二次TCP连接发起，连接正常完成。第二次连接释放后，第一次连接请求到达了服务器端，服务器以为客户端新发起了TCP连接而发送确认报文，但客户端处于关闭状态，不予理会。这将浪费大量资源

![第三次握手的必要性](img/第五章/第三次握手的必要性.png)

### 5.9.2  TCP 的连接释放

#### 四报文挥手

![四挥手1](img/第五章/四挥手1.png)

- 数据传输结束后，通信的双方都可释放连接。
- 现在 A 的应用进程先向其 TCP 发出连接释放 报文段，并停止再发送数据，主动关闭 TCP  连接。
-  A 把连接释放报文段首部的 FIN = 1，其序号seq = u，等待 B 的确认。

![四挥手2](img/第五章/四挥手2.png)



- B 发出确认，确认号 ack = u  1，而这个报文段自己的序号 seq = v。
- TCP 服务器进程通知高层应用进程。
- 从 A 到 B 这个方向的连接就释放了，TCP 连接,处于半关闭状态。B 若发送数据，A 仍要接收。

![四挥手3](img/第五章/四挥手3.png)

-   若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。 

![四挥手4](img/第五章/四挥手4.png)



-   A 收到连接释放报文段后，必须发出确认。 

-  在确认报文段中 ACK = 1，确认号 ack = w + 1， 自己的序号 seq = u + 1。 

TCP 连接必须经过时间 2MSL 后才真正释放掉。 

![四挥手5](img/第五章/四挥手5.png)

**A 必须等待 2MSL 的时间**

第一，为了保证 A 发送的最后一个 ACK 报文段能够到达 B。

第二，防止 “已失效的连接请求报文段”出现在本连接中。A 在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段，都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。

若第四次挥手（客户端发送确认关闭报文）后就直接进入关闭状态，则当客户端发送的确认释放连接报文若在网络中丢失了，则服务器在最后确认状态下迟迟收不到连接释放确认报文，会一直超时重传第三次挥手（连接释放报文），但客户机已进入关闭状态，不予理会

![四挥手MSL的必要性](img/第五章/四挥手MSL的必要性.png)

#### 保活计时器

![保活计时器](img/第五章/保活计时器.png)
